# Superposition

|0>と|1>の状態がさまざまな割合で重なりあった状態を生成します。
最後に紹介する任意の状態を生成する操作もありますが、基本操作の組み合わせで生成できる状態もあります。

例えば Plus Stateと呼ばれる`|+>=1/√2(|0>+|1>)`な状態を生成するには、|0>に`H`操作を与えます。
Minus Stateである`|->=1/√2(|0>-|1>)`の場合は|1>に`H`操作を適用するため、|0>に`X`操作を与えて|1>にしてから`H`操作を与えます。

エンタングルメント状態の一つベル状態`1/√2(|00>+|11>)`にするには、|00>の状態の2量子ビットの片方に`H`操作を加えたあと、その量子ビットを制御ビットとして`CNOT`操作を適用します。
`H`操作で|0>と|1>が同じ確率で測定される状態になっていますが、このとき|0>であればもう片方は|0>のまま、|1>であればもう片方を|1>に変化させる作用をもつのが`CNOT`です。

GHZ状態というのは、すべての量子ビットの状態が0になるか、1になるかの2つの状態が同じ割合で観測される状態です。
GHZ状態を作るには、どこかの量子ビット（サンプルコードの`GHZState`では先頭の量子ビット）に`H`操作を加えた後、残りの量子ビットを順番にすべてCNOTを適用します。
`ApplyToEachCA`は第一引数に指定した操作を、第2引数で指定したQubitの配列に順番に適用する操作です。
第一引数に指定する操作が複数の引数を取る場合、`_`を指定することで関数の部分適用ができます。
`ApplyToEachCA(CNOT(qubits[0], _), qubits[1..n-1])`は次のコードと同様の処理をします。

```qs
for(i in 1..n-1) {
  CNOT(qubits[0], qubits[i]);
}
```

`_`に、第二引数で指定したQubitの配列が順番に代入されます。
また、`qubits[1..n-1]`はqubitsという配列のうち配列インデックスが1からn-1までの部分配列となります。

最後に`SuperpositionOfThreeStatesA（B,C）`というのは[Q# Coding Contest Winter 2019](https://codeforces.com/contest/1002/problem/A3)で出題された問題です。
[解説](https://assets.codeforces.com/rounds/1115/warmup-editorial.pdf)に記載されている3つの解放をA,B,Cとして載せています。
Aは回転操作と制御ビットを使う方法、Bは確率的にうまくいく操作を使ってうまくいくまで繰り返す`repeat-until`構文を使う方法、Cは`PrepareUniformSuperposition`というQ#に用意されている操作を使う方法です。
